# Visualización de datos

## Introducción

> "El gráfico simple ha traído más información a la mente del analista  
> de datos que cualquier otro dispositivo." --- John Tukey

Este capítulo le enseñará cómo visualizar sus datos usando ggplot2. R tiene varios sistemas para hacer gráficos, pero ggplot2 es uno de los más elegantes y versátiles. ggplot2 implementa la __gramática de los gráficos__, un sistema coherente para describir y construir gráficos. Con ggplot2, puede hacerlo más rápido aprendiendo un sistema y aplicándolo en muchos lugares.

Si quiere aprender más sobre los fundamentos teóricos de ggplot2 antes de empezar, le recomiendo leer "The Layered Grammar of Graphics", <http://vita.had.co.nz/papers/layered-grammar.pdf>.

### Prerequisitos

Este capítulo se centra en ggplot2, uno de los miembros centrales del tidyverse. Para acceder a los conjuntos de datos, páginas de ayuda y funciones que utilizaremos en este capítulo, cargue el tidyverse ejecutando este código:

```{r setup}
library(tidyverse)
```

Esa simple línea de código carga el núcleo tidyverse; los paquetes que utilizará en casi todos los análisis de datos. También le dice qué funciones de tidyverse entran en conflicto con las funciones en la base R (o de otros paquetes que podría haber cargado).

Si ejecuta este código y recibe el mensaje de error "no hay ningún paquete llamado 'tidyverse'", necesitará instalarlo primero, luego ejecutar `library ()` una vez más.

```{r eval = FALSE}
install.packages("tidyverse")
library(tidyverse)
```

Sólo necesita instalar un paquete una vez, pero debe volver a cargarlo cada vez que inicie una nueva sesión.

Si necesitamos ser explícitos sobre el origen de una función (o conjunto de datos), utilizaremos la forma especial `package::function()`. Por ejemplo, `ggplot2::ggplot()` le indica explícitamente que estamos utilizando la función `ggplot()` del paquete ggplot2.

## Primeros pasos

Utilicemos nuestro primer gráfico para responder a una pregunta: ¿Los automóviles con motores grandes utilizan más combustible que los coches con motores pequeños? Usted probablemente ya tiene una respuesta, pero trate de hacer su respuesta precisa. ¿Qué aspecto tiene la relación entre el tamaño del motor y la eficiencia del combustible? ¿Es positivo? ¿Negativo? ¿Lineal? ¿No lineal?

### El data frame `mpg` 

Puede probar su respuesta con el __data frame__ `mpg` encontrado en ggplot2 (también conocido como `ggplot2::mpg`). Un data frame es una colección rectangular de variables (en las columnas) y observaciones (en las filas). `mpg` contiene observaciones recopiladas por la Agencia de Protección Ambiental de los Estados Unidos sobre 38 modelos de automóviles.

```{r}
mpg
```

Entre las variables en `mpg` están:

1. `displ`, el tamaño del motor de un automóvil, en litros.

1. `hwy`, La eficiencia de combustible de un automóvil en la carretera, en      millas por galón (mpg). 

  Un coche con un bajo consumo de combustible consume más combustible que un automóvil con una alta eficiencia de combustible cuando viajan a la misma distancia. 

Para aprender más acerca de `mpg`, abra su página de ayuda ejecutando `?mpg`.

### Creando un ggplot

Para graficar `mpg`, ejecute este código para poner `displ` en el eje de las x y `hwy` en el eje de las y:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

El gráfico muestra una relación negativa entre el tamaño del motor (`displ`) y la eficiencia de combustible (`hwy`). En otras palabras, los automóviles con motores grandes consumen más combustible. ¿Esto confirma o refuta su hipótesis sobre la eficiencia del combustible y el tamaño del motor?

Con ggplot2, usted comienza un gráfico con la función `ggplot()`. `ggplot()` crea un sistema coordenado al que pueden adherírsele capas. El primer argumento de `ggplot()` es el conjunto de datos a usar en la gráfica. Así que `ggplot(data = mpg)` crea un gráfica vacía, pero no es muy interesante, así que no voy a mostrarlo aquí.

Complete el gráfico agregando una o más capas a `ggplot()`. La función `geom_point()` añade una capa de puntos a su trazado, lo que crea un diagrama de dispersión. ggplot2 viene con muchas funciones geom que cada una agrega un tipo diferente de capa a una trama. Aprenderá un montón de ellos a lo largo de este capítulo.

Cada función geom en ggplot2 toma un argumento `mapping`. Esto define cómo las variables en su conjunto de datos se asignan a las propiedades visuales. El argumento `mapping` siempre está emparejado con `aes()`, y los argumentos `x` y `y` de `aes()` especifican qué variables asignar a los ejes x y y. ggplot2 busca la variable asignada en el argumento `data`, en este caso, `mpg`.

### Una plantilla de gráficos

Vamos a convertir este código en una plantilla reutilizable para hacer gráficos con ggplot2. Para hacer un gráfico, reemplace las secciones entre corchetes en el código siguiente con un conjunto de datos, una función geom o una colección de asignaciones.

```{r eval = FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

El resto de este capítulo le mostrará cómo completar y ampliar esta plantilla para crear diferentes tipos de gráficos. Comenzaremos con el componente `<MAPPINGS>`.

### Ejercicios

1.  Ejecute `ggplot(data = mpg)` ¿Qué ve?

1.  ¿Cuántas filas hay en `mtcars`? ¿Cuántas columnas?

1.  ¿Qué describe la variable `drv`?  Lea la ayuda de `?mpg`.
     
1.  Haga un gráfico de dispersión de `hwy` vs `cyl`.

1.  ¿Qué pasa si hace un gráfico de dispersión de `class` vs `drv`? ¿Por       qué no es útl el gráfico?

## Mapeos estéticos

> "El mayor valor de una imagen es cuando nos obliga a notar lo que nunca    esperábamos ver." --- John Tukey

En la gráfica de abajo, un grupo de puntos (destacado en rojo) parece estar fuera de la tendencia lineal. Estos coches tienen un kilometraje más alto de lo que cabría esperar. ¿Cómo puedes explicar estos coches?

```{r, echo = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), colour = "red", size = 2.2)
```

Vamos a la hipótesis de que los coches son híbridos. Una manera de probar esta hipótesis es mirar el valor `class` para cada coche. La variable `class` del conjunto de datos `mpg` clasifica los coches en grupos como compactos, medianos y SUV. Si los puntos periféricos son híbridos, deben clasificarse como coches compactos o, quizá, para automóviles subcompactos (tenga en cuenta que estos datos se recolectaron antes de que los camiones híbridos y SUV se hicieran populares).

Puede agregar una tercera variable, como `class`, a un diagrama de dispersión bidimensional asignándolo a un __aesthetic__. Una estética es una propiedad visual de los objetos de su gráfico. La estética incluye cosas como el tamaño, la forma o el color de sus puntos. Puede mostrar un punto (como el que se muestra a continuación) de diferentes maneras cambiando los valores de sus propiedades estéticas. Dado que ya utilizamos la palabra "valor" para describir los datos, utilicemos la palabra "nivel" para describir las propiedades estéticas. Aquí cambiamos los niveles de tamaño, forma y color de un punto para hacer que el punto sea pequeño, triangular o azul:

```{r, echo = FALSE, asp = 1/4}
ggplot() +
  geom_point(aes(1, 1), size = 20) +
  geom_point(aes(2, 1), size = 10) + 
  geom_point(aes(3, 1), size = 20, shape = 17) + 
  geom_point(aes(4, 1), size = 20, colour = "blue") + 
  scale_x_continuous(NULL, limits = c(0.5, 4.5), labels = NULL) + 
  scale_y_continuous(NULL, limits = c(0.9, 1.1), labels = NULL) + 
  theme(aspect.ratio = 1/3)
```

Puede transmitir información sobre sus datos trazando la estética en su gráfico a las variables de su conjunto de datos. Por ejemplo, puede asignar los colores de sus puntos a la variable `class` para revelar la clase de cada coche.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

(Si prefiere Inglés Británico, como Hadley, puede usar `colour` en lugar de `color`.)

Para asignar una estética a una variable, asocie el nombre de la estética al nombre de la variable dentro de `aes()`. ggplot2 asignará automáticamente un nivel único de la estética (aquí un color único) a cada valor único de la variable, un proceso conocido como __scaling__. ggplot2 también agregará una leyenda que explique qué niveles corresponden a qué valores.

Los colores revelan que muchos de los puntos inusuales son coches de dos plazas. Estos coches no parecen híbridos, y son, de hecho, ¡los coches deportivos! Los coches deportivos tienen motores grandes como SUVs y camionetas, pero pequeños cuerpos como automóviles medianos y compactos, lo que mejora su consumo de gasolina. En retrospectiva, estos coches eran poco probables que fueran híbridos puesto que tienen motores grandes.

En el ejemplo anterior, asignamos `class` a la estética del color, pero podríamos haber asignado `class` al tamaño estético de la misma manera. En este caso, el tamaño exacto de cada punto revelaría su afiliación de clase. Tenemos un _warning_ aquí, porque la asignación de una variable no ordenada (`class`) a una estética ordenada (`size`) no es una buena idea.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

O podríamos haber asignado `class` a la estética _alpha_, que controla la transparencia de los puntos, o la forma de los puntos.

```{r out.width = "50%", fig.align = 'default', warning = FALSE, fig.asp = 1/2, fig.cap =""}
# Izquiera
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

# Derecha
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

¿Qué pasó con los SUV? ggplot2 sólo usará seis formas a la vez. De forma predeterminada, los grupos adicionales no se muestran cuando se utiliza la forma estética.

Para cada estética, se utiliza `aes()` para asociar el nombre de la estética con una variable a mostrar. La función `aes ()` reúne cada una de las asignaciones estéticas utilizadas por una capa y las pasa al argumento de mapeo de la capa. La sintaxis resalta una visión útil sobre `x` y `y`: las ubicaciones x e y de un punto son propiedades estéticas por sí mismas, las propiedades visuales que se pueden asignar a variables para mostrar información sobre los datos.

Una vez que se asigna una estética, ggplot2 se encarga del resto. Selecciona una escala razonable para usar con la estética, y construye una leyenda que explica la asignación entre niveles y valores. Para la estética x e y, ggplot2 no crea una leyenda, sino que crea una línea de eje con marcas y una etiqueta. La línea de eje actúa como una leyenda; Explica la relación entre ubicaciones y valores.

También puede hacer _set_ (configurar) a las propiedades estéticas de su geom manualmente. Por ejemplo, podemos hacer que todos los puntos de nuestro gráfico sean azules:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

Aquí, el color no transmite información sobre una variable, sino que sólo cambia la apariencia de la trama. Para establecer una estética manualmente, establezca la estética por su nombre como un argumento de su función geom; Es decir, va _outside_ de `aes ()`. Tendrá que elegir un valor que tenga sentido para esa estética:

* El nombre de un color como una cadena de caracteres.

* El tamaño de un punto en mm.

* La forma de un punto como un número, como se muestra en la figura \@ref(fig:shapes).

```{r shapes, echo = FALSE, out.width = "75%", fig.asp = 1/3, fig.cap="R tiene 25 formas construidas que se identifican por números. Hay algunos duplicados aparentes: por ejemplo, 0, 15 y 22 son todos los cuadrados. La diferencia proviene de la interacción de las estéticas `colour` y `fill`. Las formas huecas (0-14) tienen un borde determinado por `colour`; Las formas sólidas (15-18) están llenas con `colour`; las formas rellenas (21 - 24) tienen un borde de `color` y se llenan con `fill`.", warning = FALSE}
shapes <- tibble(
  shape = c(0, 1, 2, 5, 3, 4, 6:19, 22, 21, 24, 23, 20),
  x = (0:24 %/% 5) / 2,
  y = (-(0:24 %% 5)) / 4
)
ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL, limits = c(-1.2, 0.2)) + 
  theme_minimal() +
  theme(aspect.ratio = 1/2.75)
```

### Ejercicios

1.  ¿Qué está mal con este código? ¿Por qué los puntos no son azules?

    ```{r}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
    ```
    
1.  Qué variables en `mpg` son categóricas? ¿Cuáles son continuas? 
    (Pista: digite `?mpg` para obtener documentación del conjunto de datos).     ¿Cómo puede ver esta información cuando ejecuta `mpg`?

1.  Asigne una variable continua a `color`, `size`, y `shape`. ¿Cómo se         comportan estas estéticas de manera diferente para variables categóricas     vs. continuas? 
    
1.  ¿Qué pasa si asigna la misma variable a múltiples estéticas? 

1.  ¿Qué hace la estética `stroke`? ¿Con qué formas trabaja? (Pista: use        `?geom_point`)
    
1.  ¿Qué sucede si se asigna una estética a algo que no sea un nombre de        variable, como `aes(colour = displ < 5)`?  

## Problemas comunes

A medida que empiece a ejecutar el código en R, es probable que se encuentre con problemas. No se preocupe --- le pasa a todo el mundo. ¡He estado escribiendo el código en R por años, y cada día todavía escribo código que no trabaja!

Comience comparando cuidadosamente el código que está ejecutando con el código del libro. R es extremadamente exigente, y un caracter mal colocado puede hacer toda la diferencia. Asegúrese de que cada `(` coincida con un `)` y que cada `"` esté emparejado con otro `"`. A veces se ejecuta el código y no pasa nada. Compruebe la parte izquierda de su consola: si hay un `+`, significa que R no cree que ha escrito una expresión completa y está esperando a que termine. En este caso, es usualmente fácil empezar de cero de nuevo presionando ESCAPE para abortar procesando el comando actual.

Un problema común al crear gráficos de ggplot2 es poner el `+` en el lugar incorrecto: tiene que venir al final de la línea, no el comienzo. En otras palabras, asegúrese de que no ha escrito accidentalmente código como este:

```R
ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))
```

Si todavía está atascado, pruebe la ayuda. Puede obtener ayuda sobre cualquier función R ejecutando `?function_name` en la consola o seleccionando el nombre de la función y pulsando F1 en RStudio. No se preocupe si la ayuda no parece tan útil - en lugar de saltar a los ejemplos y buscar el código que coincida con lo que está tratando de hacer.

Si eso no ayuda, lea cuidadosamente el mensaje de error. ¡A veces la respuesta está enterrada allí! Pero cuando se es nuevo en R, la respuesta puede estar en el mensaje de error pero aún no sabe cómo entenderlo. Otra gran herramienta es Google: pruebe googlear el mensaje de error, ya que es probable que alguien más haya tenido el mismo problema, y haya obtenido ayuda en línea.

## Facets

Una forma de agregar variables adicionales es con la estética. Otra forma, especialmente útil para las variables categóricas, es dividir su gráfico en __facets__, subgráficos que muestran un subconjunto de los datos.

Para hacer facet a su gráfico con una sola variable, use `facet_wrap()`. El primer argumento de `facet_wrap()` debería ser una fórmula, que se crea con `~` seguido de un nombre de variable (aquí "formula" es el nombre de una estructura de datos en R, no un sinónimo de "ecuación"). La variable que pasa a `facet_wrap()` debe ser discreta.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

Para hacer facet a su gráfico en la combinación de dos variables, agregue `facet_grid()` a su llamada de gráfico. El primer argumento de `facet_grid()` es también una fórmula. Esta vez, la fórmula debe contener dos nombres de variables separados por un `~`.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

Si prefiere no formar facet en la dimensión de filas o columnas, use un `.` en lugar de un nombre de variable, por ejemplo, `+ facet_grid(. ~ cyl)`.

### Ejercicios

1.  ¿Qué sucede si se trata de una variable continua?

1.  ¿Qué significan las celdas vacías en el gráfico con `facet_grid (drv ~      cyl)`? ¿Cómo se relacionan con este gráfico?
    
    ```{r, eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = drv, y = cyl))
    ```

1.  ¿Qué gráficos hacen el siguiente código? ¿Qué hace `.`?

    ```{r eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)
    
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(. ~ cyl)
    ```

1.  Tome el primer gráfico con facet en esta sección:

    ```{r, eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) + 
      facet_wrap(~ class, nrow = 2)
    ```
    
    ¿Cuáles son las ventajas de usar facet en vez de la estética de color?
    ¿Cuáles son las desventajas? ¿Cómo podría cambiar el equilibrio si          tuviera un conjunto de datos más grande?
    
1.  Lea `?facet_wrap`. ¿Qué hace `nrow`? ¿Qué hace `ncol`? ¿Qué otras           opciones controlan el diseño de los paneles individuales? ¿Por qué          `facet_grid()` no tiene variables `nrow` y `ncol`?

1.  Cuando utilice `facet_grid()`, normalmente debería poner la variable con     niveles más únicos en las columnas. ¿Por qué?

## Objetos Geométricos

¿Por qué estos dos gráficos son similares? 

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Ambos gráficos contienen la misma variable x, la misma variable y, y ambos describen los mismos datos. Pero los gráficos no son idénticas. Cada uno utiliza un objeto visual diferente para representar los datos. En la sintaxis ggplot2, decimos que usan diferentes __geoms__.

Un __geom__ es el objeto geométrico que un gráfico utiliza para representar datos. La gente a menudo describe gráficos por el tipo de geom que usa. Por ejemplo, los gráficos de barras usan geoms de barras, los gráficos de líneas utilizan geoms de líneas, los gráficos de barras utilizan geoms de boxplot, etc. Los diagramas de dispersión rompen la tendencia; Utilizan el punto geom. Como vimos anteriormente, puede usar diferentes geoms para trazar los mismos datos. El gráfico de la izquierda utiliza el punto geom, y el gráfico de la derecha utiliza el geom smooth, una línea suave ajustada a los datos.

Para cambiar el geom en el gráfico, cambie la función geom que agrega a `ggplot()`. Por ejemplo, para hacer los gráficos de arriba, puede utilizar este código:

```{r eval = FALSE}
# left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# right
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Cada función geom en ggplot2 toma un argumento `mapping`. Sin embargo, no todas las estéticas trabajan con todas las geom. Podría establecer la forma de un punto, pero no podría establecer la "forma" de una línea. Por otro lado, usted podría establecer el tipo de línea de una línea. `geom_smooth()` dibujará una línea diferente, con un tipo de línea diferente, para cada valor único de la variable que se asigna al tipo de línea.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

Aquí `geom_smooth()` separa los coches en tres líneas basados en su valor `drv`, que describe la transmisión de un coche. Una línea describe todos los puntos con un valor `4`, una línea describe todos los puntos con un valor` f`, y una línea describe todos los puntos con un valor `r`. En este caso, `4` significa tracción a las cuatro ruedas,` f` para la tracción delantera y `r` para tracción trasera.

Si esto suena extraño, podemos hacerlo más claro superponiendo las líneas encima de los datos sin procesar y luego coloreándolo todo de acuerdo con `drv`. 

```{r echo = FALSE, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() +
  geom_smooth(mapping = aes(linetype = drv))
```

¡Observe que esta gráfica contiene dos geoms en el mismo gráfico! Si esto lo ha sorprendido, abróchese el cinturón. En la siguiente sección, aprenderemos a colocar varios geoms en el mismo gráfico.

ggplot2 proporciona más de 30 geoms y los paquetes de extensión proporcionan aún más (ver <https://www.ggplot2-exts.org> para una muestra). La mejor manera de obtener una visión general es el cheatsheet de ggplot2, que puede encontrar en <http://rstudio.com/cheatsheets>. Para obtener más información acerca de cualquier geom simple, utilice la ayuda: `?geom_smooth`.

Muchos geoms, como `geom_smooth()`, utilizan un solo objeto geométrico para mostrar varias filas de datos. Para estos geoms, puede establecer la estética `group` a una variable categórica para dibujar varios objetos. ggplot2 dibujará un objeto separado para cada valor único de la variable de agrupación. En la práctica, ggplot2 agrupará automáticamente los datos para estos geoms cada vez que se asigne una estética a una variable discreta (como en el ejemplo `linetype`). Es conveniente confiar en esta característica porque la estética del grupo por sí misma no añade una leyenda o características distintivas a los geoms.

```{r, fig.width = 3, fig.align = 'default', out.width = "33%", message = FALSE}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
    
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, group = drv)
  )
```

Para mostrar varios geoms en el mismo gráfico, agregue varias funciones de geom a `ggplot ()`:

```{r, message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

Esto, sin embargo, introduce cierta duplicación en nuestro código. Imagine que desea cambiar el eje y para mostrar `cty` en lugar de` hwy`. Tendría que cambiar la variable en dos lugares, y es posible que se olvide de actualizar una. Puede evitar este tipo de repetición pasando un conjunto de asignaciones a `ggplot()`. ggplot2 tratará estas asignaciones como asignaciones globales que se aplican a cada geom en el gráfico. En otras palabras, este código producirá el mismo gráfico que el código anterior:

```{r, eval = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

Si coloca asignaciones en una función geom, ggplot2 las tratará como asignaciones locales para la capa. Utilizará estas asignaciones para extender o sobrescribir las asignaciones globales _para esa capa solamente_. Esto hace posible visualizar estéticas diferentes en diferentes capas.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Puede utilizar la misma idea para especificar diferentes `datos` para cada capa. Aquí, nuestra línea suave muestra sólo un subconjunto del conjunto de datos `mpg`, los coches subcompactos. El argumento de datos locales en `geom_smooth()` anula el argumento de datos globales en `ggplot()` sólo para esa capa.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```

(Aprenderá cómo funciona `filter()` en el siguiente capítulo: por ahora, sólo sepa que este comando selecciona sólo los coches subcompactos.)

### Ejercicios

1.  ¿Qué geom usaría para dibujar un gráfico de líneas? ¿Un boxplot?
    ¿Un histograma? ¿Un gráfico de área?

1.  Ejecute este código en su cabeza y prediga cómo será la salida.
    A continuación, ejecute el código en R y compruebe sus predicciones.
    
    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ```

1.  ¿Qué hace `show.legend = FALSE`? ¿Qué sucede si lo retira?
    ¿Por qué cree que lo usé antes en el capítulo?

1.  ¿Qué hace el argumento `se` en `geom_smooth()`?


1.  ¿Serán estos dos gráficos diferentes? ¿Por qué sí o por qué no?

    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth()
    
    ggplot() + 
      geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
    ```

1.  Recree el código en R necesario para generar los siguientes gráficos.
    
    ```{r echo = FALSE, fig.width = 3, out.width = "50%", fig.align = "default", message = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(aes(group = drv), se = FALSE) +
      geom_point()
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) +
      geom_smooth(aes(linetype = drv), se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(size = 4, colour = "white") + 
      geom_point(aes(colour = drv))
    ```

## Transformaciones estadísticas

A continuación, echemos un vistazo a un gráfico de barras. Los gráficos de barras parecen simples, pero son interesantes porque revelan algo sutil sobre los datos. Considere un gráfico de barras básico, como se ha dibujado con `geom_bar()`. La siguiente tabla muestra el número total de diamantes en el conjunto de datos `diamonds`, agrupados por `cut`. El conjunto de datos `diamonds` viene en ggplot2 y contiene información sobre ~54.000 diamantes, incluyendo el `price`, `carat`,`color`, `clarity` y `cut` de cada diamante. El gráfico muestra que más diamantes están disponibles con cortes de alta calidad que con cortes de baja calidad.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

En el eje x, el gráfico muestra `cut`, una variable de `diamonds`. En el eje y, muestra count, pero ¡count no es una variable en `diamonds`! ¿De dónde proviene count? Muchos gráficos, como los diagramas de dispersión, grafican los valores sin procesar de su conjunto de datos. Otros gráficos, como gráficos de barras, calculan nuevos valores para graficar:

* gráficos de barras, histogramas y polígonos de frecuencia encajan sus datos y luego el gráfico cuenta los grupos, el número de puntos que caen en cada compartimiento.

* los smoothers ajustan un modelo a sus datos y luego trazan las predicciones del modelo.

* los boxplots calculan un resumen robusto de la distribución y luego muestran una caja con formato especial.

El algoritmo utilizado para calcular nuevos valores para un gráfico se denomina __stat__, abreviación de transformación estadística. La siguiente figura describe cómo funciona este proceso con `geom_bar()`.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-stat-bar.png")
```

Puede averiguar qué estadística geom utiliza al inspeccionar el valor predeterminado del argumento `stat`. Por ejemplo, `?geom_bar` muestra el valor por defecto de `stat` es "count", lo que significa que `geom_bar()` utiliza `stat_count()`. `stat_count()` está documentado en la misma página que `geom_bar()`, y si se desplaza hacia abajo puede encontrar una sección llamada "Variables calculadas". Esto indica que calcula dos nuevas variables: `count` y `prop`.

Generalmente puede usar geoms y stats intercambiablemente. Por ejemplo, puede volver a crear la trama anterior usando `stat_count()` en lugar de `geom_bar()`:

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

Esto funciona porque cada geom tiene una estadística predeterminada; y cada stat tiene un geom predeterminado. Esto significa que normalmente puede utilizar geoms sin preocuparse por la transformación estadística subyacente. Hay tres razones por las que puede ser necesario utilizar una estadística explícitamente:

1.  Es posible que desee anular el stat predeterminado. En el código de         abajo, cambio el stat de `geom_bar()` de count (el valor predeterminado)     a identity. Esto me permite asignar la altura de las barras a los           valores sin procesar de una variable $y$.
    Desafortunadamente, cuando las personas hablan de gráficos de barras        casualmente, pueden estar refiriéndose a este tipo de gráfico de barras,     donde la altura de la barra ya está presente en los datos o el gráfico      de barras anterior, donde la altura de la barra se genera contando          filas.
    
    ```{r, warning = FALSE}
    demo <- tribble(
      ~a,      ~b,
      "bar_1", 20,
      "bar_2", 30,
      "bar_3", 40
    )
    
    ggplot(data = demo) +
      geom_bar(mapping = aes(x = a, y = b), stat = "identity")
    ```
    
(No se preocupe porque no ha visto antes `<-` o `tribble()`. Puede ser capaz de adivinar su significado desde el contexto, y ¡aprenderá exactamente lo que hacen pronto!)

1. Es posible que desee anular la asignación predeterminada de las variables    transformadas a la estética. Por ejemplo, puede que desee mostrar un        gráfico de barras de proporción, en lugar de contar:
    
    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
    ```

    Para encontrar las variables calculadas por el stat, busque la sección      de ayuda titulada "variables calculadas".
    
1.  Es posible que desee llamar la atención sobre la transformación             estadística en su código. Por ejemplo, puede usar `stat_summary()`, que     resume los valores de y para cada valor x único, para llamar la atención     sobre el resumen que está computando:
    
    ```{r}
    ggplot(data = diamonds) + 
      stat_summary(
        mapping = aes(x = cut, y = depth),
        fun.ymin = min,
        fun.ymax = max,
        fun.y = median
      )
    ```
    
ggplot2 proporciona más de 20 estadísticas para su uso. Cada estadística es una función, por lo que puede obtener ayuda de la forma habitual, por ejemplo `?stat_bin`. Para ver una lista completa de estadísticas, pruebe el cheatsheet de ggplot2.

### Ejercicios

1.  ¿Cuál es el geom predeterminado asociado con `stat_summary()`? ¿Cómo        podría reescribir el gráfico anterior para usar esa función geom en         lugar de la función stat?

1.  ¿Qué hace `geom_col()`? ¿En qué se diferencia de `geom_bar()`?

1.  La mayoría de geoms y stats vienen en parejas que casi siempre se usan      en conjunto. Lea la documentación y haga una lista de todos los pares.      ¿Qué tienen en común?

1.  ¿Qué variables calcula `stat_smooth()`? ¿Qué parámetros controlan su        comportamiento?

1.  En nuestro gráfico de barras de proporción, necesitamos establecer          `group = 1`. ¿Por qué? En otras palabras, ¿cuál es el problema con estos     dos gráficos?
    
    ```{r, eval = FALSE}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop..))
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
    ```
  

## Ajustes de posición

Hay una pieza más de magia asociada con gráficos de barras. Puede colorear un gráfico de barras utilizando la estética `colour`, o más útil, `fill`:

```{r out.width = "50%", fig.align = "default"}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

Tenga en cuenta lo que sucede si asigna la estética de relleno a otra variable, como `clarity`: las barras se apilan automáticamente. Cada rectángulo coloreado representa una combinación de `cut` y `clarity`.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

El apilamiento se hace automáticamente mediante el __ajuste de posición__ especificado por el argumento `position`. Si no quiere un gráfico de barras apilado, puede usar una de las tres opciones: `"identity"`, `"dodge"` o `"fill"`.

*   `position = "identity"` colocará cada objeto exactamente donde cae en el     contexto de la gráfica. Esto no es muy útil para las barras, porque las     superpone. Para ver esa superposición necesitamos hacer las barras          ligeramente transparentes poniendo `alpha` a un valor pequeño, o            completamente transparente poniendo` fill = NA`.
    
    ```{r out.width = "50%", fig.align = "default"}
    ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
      geom_bar(alpha = 1/5, position = "identity")
    ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
      geom_bar(fill = NA, position = "identity")
    ```
    
   El ajuste de posición identity es más útil para geoms 2d, como puntos, donde es el predeterminado.
    
*   `position = "fill"` funciona como apilar, pero hace que cada conjunto de barras apiladas tenga la misma altura. Esto hace que sea más fácil comparar proporciones entre grupos.

    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
    ```

*   `position = "dodge"` coloca los objetos superpuestos uno al lado del otro _beside_. Esto facilita la comparación de valores individuales.

    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
    ```

Hay otro tipo de ajuste que no es útil para los gráficos de barras, pero puede ser muy útil para los diagramas de dispersión. Recuerde nuestro primer diagrama de dispersión. ¿Notó que la gráfica muestra sólo 126 puntos, aunque hay 234 observaciones en el conjunto de datos?

```{r echo = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

Los valores de `hwy` y `displ` son redondeados por lo que los puntos aparecen en una cuadrícula y muchos puntos se superponen entre sí. Este problema se conoce como __overplotting__. Esta disposición hace difícil ver dónde está la masa de los datos. ¿Están los puntos de datos distribuidos por igual en todo el gráfico, o hay una combinación especial de `hwy` y `displ` que contiene 109 valores?

Puede evitar esta rejilla calibrando el ajuste de posición a "jitter". `position = "jitter"` añade una pequeña cantidad de ruido aleatorio a cada punto. Esto difunde los puntos porque no hay dos puntos que puedan recibir la misma cantidad de ruido aleatorio.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

Añadir aleatoriedad parece una forma extraña de mejorar su gráfico, pero hace que su gráfica sea menos precisa en pequeñas escalas, hace que su gráfica se revele mejor a grandes escalas. Debido a que esta es una operación tan útil, ggplot2 viene con una abreviatura para `geom_point(position = "jitter")`: `geom_jitter()`.

Para aprender más acerca del ajuste de posición, eche un vistazo a la página de ayuda de cada ajuste: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, y `?position_stack`.

### Ejercicios

1.  ¿Cuál es el problema con esta gráfica? ¿Cómo podría mejorarla?

    ```{r}
    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
      geom_point()
    ```

1.  ¿Qué parámetros de `geom_jitter()` controlan la cantidad de jittering?

1.  Compare y contraste `geom_jitter()` con `geom_count()`.

1.  ¿Cuál es el ajuste de posición predeterminado para `geom_boxplot()`?        Cree una visualización del dataset `mpg` que lo demuestre.

## Sistemas coordenados

Los sistemas de coordenadas son probablemente la parte más complicada de ggplot2. El sistema de coordenadas por defecto es el sistema de coordenadas cartesianas donde las posiciones x e y actúan independientemente para encontrar la ubicación de cada punto. Hay una serie de otros sistemas de coordenadas que son de vez en cuando útiles.

*   `coord_flip()` cambia los ejes x e y. Esto es útil (por ejemplo), si desea gráficos de caja horizontal. También es útil para etiquetas largas: es difícil conseguir que encajen sin superponerse en el eje x.
    
    ```{r fig.width = 3, out.width = "50%", fig.align = "default"}
    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot()
    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot() +
      coord_flip()
    ```

*   `coord_quickmap()` establece la relación de aspecto correctamente para los mapas. Esto es muy importante si está trazando datos espaciales con ggplot2 (que desafortunadamente no tenemos el espacio para cubrir en este libro).

    ```{r fig.width = 3, out.width = "50%", fig.align = "default", message = FALSE}
    nz <- map_data("nz")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black") +
      coord_quickmap()
    ```

*   `coord_polar()` usa coordenadas polares. Las coordenadas polares revelan una conexión interesante entre un gráfico de barras y un gráfico de Coxcomb.
    
    ```{r fig.width = 3, out.width = "50%", fig.align = "default", fig.asp = 1}
    bar <- ggplot(data = diamonds) + 
      geom_bar(
        mapping = aes(x = cut, fill = cut), 
        show.legend = FALSE,
        width = 1
      ) + 
      theme(aspect.ratio = 1) +
      labs(x = NULL, y = NULL)
    
    bar + coord_flip()
    bar + coord_polar()
    ```

### Ejercicios

1.  Convierta un gráfico de barras apiladas en un gráfico circular              utilizando `coord_polar()`.

1.  ¿Qué hace el `labs()`? Lea la documentación.

1.  ¿Cuál es la diferencia entre `coord_quickmap()` y `coord_map `?

1.  ¿Qué le dice la gráfica de abajo acerca de la relación entre ciudad y       carretera mpg? ¿Por qué `coord_fixed()` es importante? ¿Qué hace            `geom_abline()`?
    
    ```{r, fig.asp = 1, out.width = "50%"}
    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```

## La gramática en capas de los gráficos

En las secciones anteriores, aprendió mucho más que cómo hacer diagramas de dispersión, gráficos de barras y diagramas de caja. Aprendió una entidad que puede usar para hacer cualquier tipo de gráfico con ggplot2. Para ver esto, vamos a agregar ajustes de posición, estadísticas, sistemas de coordenadas y facet a nuestra plantilla de código:

```
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

Nuestra nueva plantilla toma siete parámetros, las palabras entre corchetes que aparecen en la plantilla. En la práctica, rara vez es necesario proporcionar todos los siete parámetros para hacer un gráfico porque ggplot2 proporcionará valores por defecto útiles para todo, excepto los datos, las asignaciones y la función geom.

Los siete parámetros de la plantilla componen la gramática de los gráficos, un sistema formal para construir parcelas. La gramática de los gráficos se basa en la idea de que se puede describir de forma única _cualquier_ gráfico como una combinación de un conjunto de datos, un geom, un conjunto de asignaciones, un stat, un ajuste de posición, un sistema de coordenadas y un esquema de facet.

Para ver cómo funciona esto, considere cómo podría construir un gráfico básica desde cero: podría comenzar con un conjunto de datos y luego transformarlo en la información que desea mostrar (con un stat).

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-1.png")
```

A continuación, puede elegir un objeto geométrico para representar cada observación en los datos transformados. Luego, podría utilizar las propiedades estéticas de los geoms para representar las variables en los datos. Usted mapearía los valores de cada variable a los niveles de una estética.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-2.png")
```

Después, seleccionar un sistema de coordenadas para colocar los geoms dentro. Utilizaría la ubicación de los objetos (que es en sí misma una propiedad estética) para mostrar los valores de las variables x e y. En ese momento, tendría un gráfico completo, pero podría ajustar las posiciones de los geoms dentro del sistema de coordenadas (un ajuste de posición) o dividir el gráfico en subtramas (facet). También puede ampliar el gráfico agregando una o más capas adicionales, donde cada capa adicional utiliza un conjunto de datos, un geom, un conjunto de relaciones, un stat y un ajuste de posición.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-3.png")
```

Usted podría utilizar este método para construir cualquier gráfico que imagine. En otras palabras, puede utilizar la plantilla de código que ha aprendido en este capítulo para crear cientos de miles de gráficos únicos.
